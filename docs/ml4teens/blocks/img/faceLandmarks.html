<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ml4teens.blocks.img.faceLandmarks API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ml4teens.blocks.img.faceLandmarks</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os;
import numpy as np;
import PIL;

from PIL.Image import Image;

import matplotlib.pyplot as plt;
from io import BytesIO;

from mediapipe import solutions
from mediapipe.framework.formats import landmark_pb2

import mediapipe as mp
from mediapipe.tasks import python
from mediapipe.tasks.python import vision

from ...core import Block;

#===============================================================================
class FaceLandmarks(Block):

      #-------------------------------------------------------------------------
      def __init__(self, **kwargs):
          super().__init__(**kwargs);

          # /home/fran/CODE/ML4Teens/package/notebooks/models/face_landmarker.task

          cwd = os.path.dirname(__file__);
          mwd = os.path.join(cwd, &#39;../../models&#39;);
          fwd = os.path.join(cwd, &#39;../../fonts&#39;);
          
          num_faces=self.params.faces or 1;

          base_options = python.BaseOptions(model_asset_path=os.path.join(mwd,&#39;face_landmarker.task&#39;));
          options = vision.FaceLandmarkerOptions(base_options=base_options,
                                                 output_face_blendshapes=True,
                                                 output_facial_transformation_matrixes=True,
                                                 num_faces=num_faces);
          self._model = vision.FaceLandmarker.create_from_options(options);

      #-------------------------------------------------------------------------
      @classmethod
      def names(cls, idx=None):
          
          if idx is None: return 52;
          
          if idx== 0: return &#34;_neutral&#34;;
          if idx== 1: return &#34;browDownLeft&#34;;
          if idx== 2: return &#34;browDownRight&#34;;
          if idx== 3: return &#34;browInnerUp&#34;;
          if idx== 4: return &#34;browOuterUpLeft&#34;;
          if idx== 5: return &#34;browOuterUpRight&#34;;
          if idx== 6: return &#34;cheekPuff&#34;;
          if idx== 7: return &#34;cheekSquintLeft&#34;;
          if idx== 8: return &#34;cheekSquintRight&#34;;
          if idx== 9: return &#34;eyeBlinkLeft&#34;;
          if idx==10: return &#34;eyeBlinkRight&#34;;
          if idx==11: return &#34;eyeLookDownLeft&#34;;
          if idx==12: return &#34;eyeLookDownRight&#34;;
          if idx==13: return &#34;eyeLookInLeft&#34;;
          if idx==14: return &#34;eyeLookInRight&#34;;
          if idx==15: return &#34;eyeLookOutLeft&#34;;
          if idx==16: return &#34;eyeLookOutRight&#34;;
          if idx==17: return &#34;eyeLookUpLeft&#34;;
          if idx==18: return &#34;eyeLookUpRight&#34;;
          if idx==19: return &#34;eyeSquintLeft&#34;;
          if idx==20: return &#34;eyeSquintRight&#34;;
          if idx==21: return &#34;eyeWideLeft&#34;;
          if idx==22: return &#34;eyeWideRight&#34;;
          if idx==23: return &#34;jawForward&#34;;
          if idx==24: return &#34;jawLeft&#34;;
          if idx==25: return &#34;jawOpen&#34;;
          if idx==26: return &#34;jawRight&#34;;
          if idx==27: return &#34;mouthClose&#34;;
          if idx==28: return &#34;mouthDimpleLeft&#34;;
          if idx==29: return &#34;mouthDimpleRight&#34;;
          if idx==30: return &#34;mouthFrownLeft&#34;;
          if idx==31: return &#34;mouthFrownRight&#34;;
          if idx==32: return &#34;mouthFunnel&#34;;
          if idx==33: return &#34;mouthLeft&#34;;
          if idx==34: return &#34;mouthLowerDownLeft&#34;;
          if idx==35: return &#34;mouthLowerDownRight&#34;;
          if idx==36: return &#34;mouthPressLeft&#34;;
          if idx==37: return &#34;mouthPressRight&#34;;
          if idx==38: return &#34;mouthPucker&#34;;
          if idx==39: return &#34;mouthRight&#34;;
          if idx==40: return &#34;mouthRollLower&#34;;
          if idx==41: return &#34;mouthRollUpper&#34;;
          if idx==42: return &#34;mouthShrugLower&#34;;
          if idx==43: return &#34;mouthShrugUpper&#34;;
          if idx==44: return &#34;mouthSmileLeft&#34;;
          if idx==45: return &#34;mouthSmileRight&#34;;
          if idx==46: return &#34;mouthStretchLeft&#34;;
          if idx==47: return &#34;mouthStretchRight&#34;;
          if idx==48: return &#34;mouthUpperUpLeft&#34;;
          if idx==49: return &#34;mouthUpperUpRight&#34;;
          if idx==50: return &#34;noseSneerLeft&#34;;
          if idx==51: return &#34;noseSneerRight&#34;;
          raise KeyError(f&#34;El índice {idx} no se corresponde con ningún face::landmark.&#34;);
          
      &#34;&#34;&#34;
      traducciones = {
      &#34;_neutral&#34;: &#34;neutral&#34;,
      &#34;browDownLeft&#34;: &#34;ceño fruncido izquierdo&#34;,
      &#34;browDownRight&#34;: &#34;ceño fruncido derecho&#34;,
      &#34;browInnerUp&#34;: &#34;ceño elevado interior&#34;,
      &#34;browOuterUpLeft&#34;: &#34;ceño elevado exterior izquierdo&#34;,
      &#34;browOuterUpRight&#34;: &#34;ceño elevado exterior derecho&#34;,
      &#34;cheekPuff&#34;: &#34;inflar mejillas&#34;,
      &#34;cheekSquintLeft&#34;: &#34;entrecerrar mejilla izquierda&#34;,
      &#34;cheekSquintRight&#34;: &#34;entrecerrar mejilla derecha&#34;,
      &#34;eyeBlinkLeft&#34;: &#34;parpadeo izquierdo&#34;,
      &#34;eyeBlinkRight&#34;: &#34;parpadeo derecho&#34;,
      &#34;eyeLookDownLeft&#34;: &#34;mirada abajo izquierda&#34;,
      &#34;eyeLookDownRight&#34;: &#34;mirada abajo derecha&#34;,
      &#34;eyeLookInLeft&#34;: &#34;mirada hacia dentro izquierda&#34;,
      &#34;eyeLookInRight&#34;: &#34;mirada hacia dentro derecha&#34;,
      &#34;eyeLookOutLeft&#34;: &#34;mirada hacia fuera izquierda&#34;,
      &#34;eyeLookOutRight&#34;: &#34;mirada hacia fuera derecha&#34;,
      &#34;eyeLookUpLeft&#34;: &#34;mirada arriba izquierda&#34;,
      &#34;eyeLookUpRight&#34;: &#34;mirada arriba derecha&#34;,
      &#34;eyeSquintLeft&#34;: &#34;ojo entrecerrado izquierdo&#34;,
      &#34;eyeSquintRight&#34;: &#34;ojo entrecerrado derecho&#34;,
      &#34;eyeWideLeft&#34;: &#34;ojo muy abierto izquierdo&#34;,
      &#34;eyeWideRight&#34;: &#34;ojo muy abierto derecho&#34;,
      &#34;jawForward&#34;: &#34;mandíbula hacia adelante&#34;,
      &#34;jawLeft&#34;: &#34;mandíbula izquierda&#34;,
      &#34;jawOpen&#34;: &#34;mandíbula abierta&#34;,
      &#34;jawRight&#34;: &#34;mandíbula derecha&#34;,
      &#34;mouthClose&#34;: &#34;boca cerrada&#34;,
      &#34;mouthDimpleLeft&#34;: &#34;hoyuelo izquierdo&#34;,
      &#34;mouthDimpleRight&#34;: &#34;hoyuelo derecho&#34;,
      &#34;mouthFrownLeft&#34;: &#34;ceño boca izquierda&#34;,
      &#34;mouthFrownRight&#34;: &#34;ceño boca derecha&#34;,
      &#34;mouthFunnel&#34;: &#34;boca embudo&#34;,
      &#34;mouthLeft&#34;: &#34;boca izquierda&#34;,
      &#34;mouthLowerDownLeft&#34;: &#34;boca abajo izquierda&#34;,
      &#34;mouthLowerDownRight&#34;: &#34;boca abajo derecha&#34;,
      &#34;mouthPressLeft&#34;: &#34;presión boca izquierda&#34;,
      &#34;mouthPressRight&#34;: &#34;presión boca derecha&#34;,
      &#34;mouthPucker&#34;: &#34;boca fruncida&#34;,
      &#34;mouthRight&#34;: &#34;boca derecha&#34;,
      &#34;mouthRollLower&#34;: &#34;enrollar inferior de boca&#34;,
      &#34;mouthRollUpper&#34;: &#34;enrollar superior de boca&#34;,
      &#34;mouthShrugLower&#34;: &#34;encoger inferior de boca&#34;,
      &#34;mouthShrugUpper&#34;: &#34;encoger superior de boca&#34;,
      &#34;mouthSmileLeft&#34;: &#34;sonrisa izquierda&#34;,
      &#34;mouthSmileRight&#34;: &#34;sonrisa derecha&#34;,
      &#34;mouthStretchLeft&#34;: &#34;estiramiento boca izquierda&#34;,
      &#34;mouthStretchRight&#34;: &#34;estiramiento boca derecha&#34;,
      &#34;mouthUpperUpLeft&#34;: &#34;parte superior boca arriba izquierda&#34;,
      &#34;mouthUpperUpRight&#34;: &#34;parte superior boca arriba derecha&#34;,
      &#34;noseSneerLeft&#34;: &#34;arrugar nariz izquierda&#34;,
      &#34;noseSneerRight&#34;: &#34;arrugar nariz derecha&#34;
      }
      &#34;&#34;&#34;
      
      #-------------------------------------------------------------------------
      @classmethod
      def draw_landmarks_on_image(cls, rgb_image, detection_result, params):
          face_landmarks_list = detection_result.face_landmarks
          annotated_image = np.copy(rgb_image)
        
          # Loop through the detected faces to visualize.
          for idx in range(len(face_landmarks_list)):
            face_landmarks = face_landmarks_list[idx]
        
            # Draw the face landmarks.
            face_landmarks_proto = landmark_pb2.NormalizedLandmarkList()
            face_landmarks_proto.landmark.extend([ landmark_pb2.NormalizedLandmark(x=landmark.x, y=landmark.y, z=landmark.z) for landmark in face_landmarks ])
        
            if bool(params.drawAll) is True or bool(params.tesselation) is True:
               solutions.drawing_utils.draw_landmarks(image=annotated_image, 
                                                      landmark_list=face_landmarks_proto, 
                                                      connections=mp.solutions.face_mesh.FACEMESH_TESSELATION, 
                                                      landmark_drawing_spec=None, 
                                                      connection_drawing_spec=mp.solutions.drawing_styles.get_default_face_mesh_tesselation_style())
            if bool(params.drawAll) is True or bool(params.contours) is True:
               solutions.drawing_utils.draw_landmarks(image=annotated_image, 
                                                      landmark_list=face_landmarks_proto, 
                                                      connections=mp.solutions.face_mesh.FACEMESH_CONTOURS,    
                                                      landmark_drawing_spec=None, 
                                                      connection_drawing_spec=mp.solutions.drawing_styles.get_default_face_mesh_contours_style())               
            if bool(params.drawAll) is True or bool(params.irises) is True:
               solutions.drawing_utils.draw_landmarks(image=annotated_image, 
                                                      landmark_list=face_landmarks_proto, 
                                                      connections=mp.solutions.face_mesh.FACEMESH_IRISES,      
                                                      landmark_drawing_spec=None, 
                                                      connection_drawing_spec=mp.solutions.drawing_styles.get_default_face_mesh_iris_connections_style())
        
          return annotated_image    
          
      #-------------------------------------------------------------------------
      @classmethod
      def plot_features(cls, features):
        names  = [item[&#34;name&#34; ] for item in features];
        scores = [item[&#34;score&#34;] for item in features];
        
        ranks = range(len(names));

        with BytesIO() as buff:
             fig, ax = plt.subplots(figsize=(10, 10));
             bar = ax.barh(ranks, scores, label=[str(x) for x in ranks]);
             ax.set_yticks(ranks, names);
             ax.invert_yaxis();

             for score, patch in zip(scores, bar.patches):
                 plt.text(patch.get_x() + patch.get_width(), patch.get_y(), f&#34;{score:.2f}&#34;, va=&#34;top&#34;);

             ax.set_xlabel(&#39;Score&#39;);
             ax.set_title(&#34;Features&#34;);
             plt.tight_layout();

             plt.savefig(buff, format=&#39;png&#39;);
             buff.seek(0);
             image = PIL.Image.open(buff)
             image.load();

             buff.close();
             plt.close();

        return image;
          
      #-------------------------------------------------------------------------
      # SLOTS
      #-------------------------------------------------------------------------
      @Block.slot(&#34;image&#34;, {Image})
      def slot_image(self, slot, data):

          if data:
             image = data.convert(&#39;RGB&#39;);  
             image = mp.Image(image_format=mp.ImageFormat.SRGB, data=np.asarray(image));
             results = self._model.detect(image);

             if self.signal_image():
                image = image.numpy_view();
                if bool(self.params.bb) is True:
                   image = np.zeros_like(image);
                if self.params.alpha is not None:
                   alpha=self.params.alpha;
                   alpha=max(alpha,0.0);
                   alpha=min(alpha,1.0);
                   color_fondo = np.array([0, 0, 0]);
                   color_fondo = np.tile(color_fondo, (image.shape[0], image.shape[1], 1));
                   image = image.astype(float) * alpha + color_fondo.astype(float) * (1 - alpha);
                   image = np.clip(image, 0, 255).astype(np.uint8);
                   
                salida = FaceLandmarks.draw_landmarks_on_image(image, results, self.params);
                self.signal_image(PIL.Image.fromarray(salida));

             if self.signal_landmarks():
                rt=[];
                for idx in range(len(results.face_landmarks)):
                    landmarks   = results.face_landmarks[idx];
                    blendshapes = results.face_blendshapes[idx];
                    matrix      = results.facial_transformation_matrixes[idx];
                    face={&#34;kind&#34;:f&#34;face::{0}&#34;, &#34;trust&#34;:0.0, &#34;matrix&#34;:matrix, &#34;xyz&#34;:[]};
                    for lm in landmarks:
                        face[&#34;xyz&#34;].append((lm.x, lm.y, lm.z));
                    rt.append(face);
                    
                self.signal_landmarks(rt);

             if self.signal_features():
                rt=[];
                for idx in range(len(results.face_landmarks)):
                    blendshapes = results.face_blendshapes[idx];
                    face = [ {&#34;index&#34;:bs.index, &#34;score&#34;:bs.score, &#34;name&#34;:bs.category_name} for bs in blendshapes ];
                    rt.append(face);
                    
                self.signal_features(rt);
                
             if self.signal_plot():
                if len(results.face_landmarks) &gt; 0:
                   for idx in range(len(results.face_landmarks)):
                       blendshapes = results.face_blendshapes[idx];
                       face = [ {&#34;index&#34;:bs.index, &#34;score&#34;:bs.score, &#34;name&#34;:bs.category_name} for bs in blendshapes ];
                       image = FaceLandmarks.plot_features(face);
                       self.signal_plot(image);
                else:
                   if self.params.emptyPlot:
                      face=[{&#34;index&#34;:n, &#34;score&#34;:0.0, &#34;name&#34;:FaceLandmarks.names(n)} for n in range(52)];
                      image = FaceLandmarks.plot_features(face);
                      self.signal_plot(image);
                
     #-------------------------------------------------------------------------
      # SIGNALS
      #-------------------------------------------------------------------------
      @Block.signal(&#34;image&#34;, Image)
      def signal_image(self, data):
          return data;

      @Block.signal(&#34;plot&#34;, Image)
      def signal_plot(self, data):
          return data;

      #-------------------------------------------------------------------------
      @Block.signal(&#34;landmarks&#34;, list)
      def signal_landmarks(self, data):
          return data;

      #-------------------------------------------------------------------------
      @Block.signal(&#34;features&#34;, list)
      def signal_features(self, data):
          return data;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ml4teens.blocks.img.faceLandmarks.FaceLandmarks"><code class="flex name class">
<span>class <span class="ident">FaceLandmarks</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>La clase Block, ancestro de todos los bloques y núcleo fundamental del sistema, junto con la clase Context.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FaceLandmarks(Block):

      #-------------------------------------------------------------------------
      def __init__(self, **kwargs):
          super().__init__(**kwargs);

          # /home/fran/CODE/ML4Teens/package/notebooks/models/face_landmarker.task

          cwd = os.path.dirname(__file__);
          mwd = os.path.join(cwd, &#39;../../models&#39;);
          fwd = os.path.join(cwd, &#39;../../fonts&#39;);
          
          num_faces=self.params.faces or 1;

          base_options = python.BaseOptions(model_asset_path=os.path.join(mwd,&#39;face_landmarker.task&#39;));
          options = vision.FaceLandmarkerOptions(base_options=base_options,
                                                 output_face_blendshapes=True,
                                                 output_facial_transformation_matrixes=True,
                                                 num_faces=num_faces);
          self._model = vision.FaceLandmarker.create_from_options(options);

      #-------------------------------------------------------------------------
      @classmethod
      def names(cls, idx=None):
          
          if idx is None: return 52;
          
          if idx== 0: return &#34;_neutral&#34;;
          if idx== 1: return &#34;browDownLeft&#34;;
          if idx== 2: return &#34;browDownRight&#34;;
          if idx== 3: return &#34;browInnerUp&#34;;
          if idx== 4: return &#34;browOuterUpLeft&#34;;
          if idx== 5: return &#34;browOuterUpRight&#34;;
          if idx== 6: return &#34;cheekPuff&#34;;
          if idx== 7: return &#34;cheekSquintLeft&#34;;
          if idx== 8: return &#34;cheekSquintRight&#34;;
          if idx== 9: return &#34;eyeBlinkLeft&#34;;
          if idx==10: return &#34;eyeBlinkRight&#34;;
          if idx==11: return &#34;eyeLookDownLeft&#34;;
          if idx==12: return &#34;eyeLookDownRight&#34;;
          if idx==13: return &#34;eyeLookInLeft&#34;;
          if idx==14: return &#34;eyeLookInRight&#34;;
          if idx==15: return &#34;eyeLookOutLeft&#34;;
          if idx==16: return &#34;eyeLookOutRight&#34;;
          if idx==17: return &#34;eyeLookUpLeft&#34;;
          if idx==18: return &#34;eyeLookUpRight&#34;;
          if idx==19: return &#34;eyeSquintLeft&#34;;
          if idx==20: return &#34;eyeSquintRight&#34;;
          if idx==21: return &#34;eyeWideLeft&#34;;
          if idx==22: return &#34;eyeWideRight&#34;;
          if idx==23: return &#34;jawForward&#34;;
          if idx==24: return &#34;jawLeft&#34;;
          if idx==25: return &#34;jawOpen&#34;;
          if idx==26: return &#34;jawRight&#34;;
          if idx==27: return &#34;mouthClose&#34;;
          if idx==28: return &#34;mouthDimpleLeft&#34;;
          if idx==29: return &#34;mouthDimpleRight&#34;;
          if idx==30: return &#34;mouthFrownLeft&#34;;
          if idx==31: return &#34;mouthFrownRight&#34;;
          if idx==32: return &#34;mouthFunnel&#34;;
          if idx==33: return &#34;mouthLeft&#34;;
          if idx==34: return &#34;mouthLowerDownLeft&#34;;
          if idx==35: return &#34;mouthLowerDownRight&#34;;
          if idx==36: return &#34;mouthPressLeft&#34;;
          if idx==37: return &#34;mouthPressRight&#34;;
          if idx==38: return &#34;mouthPucker&#34;;
          if idx==39: return &#34;mouthRight&#34;;
          if idx==40: return &#34;mouthRollLower&#34;;
          if idx==41: return &#34;mouthRollUpper&#34;;
          if idx==42: return &#34;mouthShrugLower&#34;;
          if idx==43: return &#34;mouthShrugUpper&#34;;
          if idx==44: return &#34;mouthSmileLeft&#34;;
          if idx==45: return &#34;mouthSmileRight&#34;;
          if idx==46: return &#34;mouthStretchLeft&#34;;
          if idx==47: return &#34;mouthStretchRight&#34;;
          if idx==48: return &#34;mouthUpperUpLeft&#34;;
          if idx==49: return &#34;mouthUpperUpRight&#34;;
          if idx==50: return &#34;noseSneerLeft&#34;;
          if idx==51: return &#34;noseSneerRight&#34;;
          raise KeyError(f&#34;El índice {idx} no se corresponde con ningún face::landmark.&#34;);
          
      &#34;&#34;&#34;
      traducciones = {
      &#34;_neutral&#34;: &#34;neutral&#34;,
      &#34;browDownLeft&#34;: &#34;ceño fruncido izquierdo&#34;,
      &#34;browDownRight&#34;: &#34;ceño fruncido derecho&#34;,
      &#34;browInnerUp&#34;: &#34;ceño elevado interior&#34;,
      &#34;browOuterUpLeft&#34;: &#34;ceño elevado exterior izquierdo&#34;,
      &#34;browOuterUpRight&#34;: &#34;ceño elevado exterior derecho&#34;,
      &#34;cheekPuff&#34;: &#34;inflar mejillas&#34;,
      &#34;cheekSquintLeft&#34;: &#34;entrecerrar mejilla izquierda&#34;,
      &#34;cheekSquintRight&#34;: &#34;entrecerrar mejilla derecha&#34;,
      &#34;eyeBlinkLeft&#34;: &#34;parpadeo izquierdo&#34;,
      &#34;eyeBlinkRight&#34;: &#34;parpadeo derecho&#34;,
      &#34;eyeLookDownLeft&#34;: &#34;mirada abajo izquierda&#34;,
      &#34;eyeLookDownRight&#34;: &#34;mirada abajo derecha&#34;,
      &#34;eyeLookInLeft&#34;: &#34;mirada hacia dentro izquierda&#34;,
      &#34;eyeLookInRight&#34;: &#34;mirada hacia dentro derecha&#34;,
      &#34;eyeLookOutLeft&#34;: &#34;mirada hacia fuera izquierda&#34;,
      &#34;eyeLookOutRight&#34;: &#34;mirada hacia fuera derecha&#34;,
      &#34;eyeLookUpLeft&#34;: &#34;mirada arriba izquierda&#34;,
      &#34;eyeLookUpRight&#34;: &#34;mirada arriba derecha&#34;,
      &#34;eyeSquintLeft&#34;: &#34;ojo entrecerrado izquierdo&#34;,
      &#34;eyeSquintRight&#34;: &#34;ojo entrecerrado derecho&#34;,
      &#34;eyeWideLeft&#34;: &#34;ojo muy abierto izquierdo&#34;,
      &#34;eyeWideRight&#34;: &#34;ojo muy abierto derecho&#34;,
      &#34;jawForward&#34;: &#34;mandíbula hacia adelante&#34;,
      &#34;jawLeft&#34;: &#34;mandíbula izquierda&#34;,
      &#34;jawOpen&#34;: &#34;mandíbula abierta&#34;,
      &#34;jawRight&#34;: &#34;mandíbula derecha&#34;,
      &#34;mouthClose&#34;: &#34;boca cerrada&#34;,
      &#34;mouthDimpleLeft&#34;: &#34;hoyuelo izquierdo&#34;,
      &#34;mouthDimpleRight&#34;: &#34;hoyuelo derecho&#34;,
      &#34;mouthFrownLeft&#34;: &#34;ceño boca izquierda&#34;,
      &#34;mouthFrownRight&#34;: &#34;ceño boca derecha&#34;,
      &#34;mouthFunnel&#34;: &#34;boca embudo&#34;,
      &#34;mouthLeft&#34;: &#34;boca izquierda&#34;,
      &#34;mouthLowerDownLeft&#34;: &#34;boca abajo izquierda&#34;,
      &#34;mouthLowerDownRight&#34;: &#34;boca abajo derecha&#34;,
      &#34;mouthPressLeft&#34;: &#34;presión boca izquierda&#34;,
      &#34;mouthPressRight&#34;: &#34;presión boca derecha&#34;,
      &#34;mouthPucker&#34;: &#34;boca fruncida&#34;,
      &#34;mouthRight&#34;: &#34;boca derecha&#34;,
      &#34;mouthRollLower&#34;: &#34;enrollar inferior de boca&#34;,
      &#34;mouthRollUpper&#34;: &#34;enrollar superior de boca&#34;,
      &#34;mouthShrugLower&#34;: &#34;encoger inferior de boca&#34;,
      &#34;mouthShrugUpper&#34;: &#34;encoger superior de boca&#34;,
      &#34;mouthSmileLeft&#34;: &#34;sonrisa izquierda&#34;,
      &#34;mouthSmileRight&#34;: &#34;sonrisa derecha&#34;,
      &#34;mouthStretchLeft&#34;: &#34;estiramiento boca izquierda&#34;,
      &#34;mouthStretchRight&#34;: &#34;estiramiento boca derecha&#34;,
      &#34;mouthUpperUpLeft&#34;: &#34;parte superior boca arriba izquierda&#34;,
      &#34;mouthUpperUpRight&#34;: &#34;parte superior boca arriba derecha&#34;,
      &#34;noseSneerLeft&#34;: &#34;arrugar nariz izquierda&#34;,
      &#34;noseSneerRight&#34;: &#34;arrugar nariz derecha&#34;
      }
      &#34;&#34;&#34;
      
      #-------------------------------------------------------------------------
      @classmethod
      def draw_landmarks_on_image(cls, rgb_image, detection_result, params):
          face_landmarks_list = detection_result.face_landmarks
          annotated_image = np.copy(rgb_image)
        
          # Loop through the detected faces to visualize.
          for idx in range(len(face_landmarks_list)):
            face_landmarks = face_landmarks_list[idx]
        
            # Draw the face landmarks.
            face_landmarks_proto = landmark_pb2.NormalizedLandmarkList()
            face_landmarks_proto.landmark.extend([ landmark_pb2.NormalizedLandmark(x=landmark.x, y=landmark.y, z=landmark.z) for landmark in face_landmarks ])
        
            if bool(params.drawAll) is True or bool(params.tesselation) is True:
               solutions.drawing_utils.draw_landmarks(image=annotated_image, 
                                                      landmark_list=face_landmarks_proto, 
                                                      connections=mp.solutions.face_mesh.FACEMESH_TESSELATION, 
                                                      landmark_drawing_spec=None, 
                                                      connection_drawing_spec=mp.solutions.drawing_styles.get_default_face_mesh_tesselation_style())
            if bool(params.drawAll) is True or bool(params.contours) is True:
               solutions.drawing_utils.draw_landmarks(image=annotated_image, 
                                                      landmark_list=face_landmarks_proto, 
                                                      connections=mp.solutions.face_mesh.FACEMESH_CONTOURS,    
                                                      landmark_drawing_spec=None, 
                                                      connection_drawing_spec=mp.solutions.drawing_styles.get_default_face_mesh_contours_style())               
            if bool(params.drawAll) is True or bool(params.irises) is True:
               solutions.drawing_utils.draw_landmarks(image=annotated_image, 
                                                      landmark_list=face_landmarks_proto, 
                                                      connections=mp.solutions.face_mesh.FACEMESH_IRISES,      
                                                      landmark_drawing_spec=None, 
                                                      connection_drawing_spec=mp.solutions.drawing_styles.get_default_face_mesh_iris_connections_style())
        
          return annotated_image    
          
      #-------------------------------------------------------------------------
      @classmethod
      def plot_features(cls, features):
        names  = [item[&#34;name&#34; ] for item in features];
        scores = [item[&#34;score&#34;] for item in features];
        
        ranks = range(len(names));

        with BytesIO() as buff:
             fig, ax = plt.subplots(figsize=(10, 10));
             bar = ax.barh(ranks, scores, label=[str(x) for x in ranks]);
             ax.set_yticks(ranks, names);
             ax.invert_yaxis();

             for score, patch in zip(scores, bar.patches):
                 plt.text(patch.get_x() + patch.get_width(), patch.get_y(), f&#34;{score:.2f}&#34;, va=&#34;top&#34;);

             ax.set_xlabel(&#39;Score&#39;);
             ax.set_title(&#34;Features&#34;);
             plt.tight_layout();

             plt.savefig(buff, format=&#39;png&#39;);
             buff.seek(0);
             image = PIL.Image.open(buff)
             image.load();

             buff.close();
             plt.close();

        return image;
          
      #-------------------------------------------------------------------------
      # SLOTS
      #-------------------------------------------------------------------------
      @Block.slot(&#34;image&#34;, {Image})
      def slot_image(self, slot, data):

          if data:
             image = data.convert(&#39;RGB&#39;);  
             image = mp.Image(image_format=mp.ImageFormat.SRGB, data=np.asarray(image));
             results = self._model.detect(image);

             if self.signal_image():
                image = image.numpy_view();
                if bool(self.params.bb) is True:
                   image = np.zeros_like(image);
                if self.params.alpha is not None:
                   alpha=self.params.alpha;
                   alpha=max(alpha,0.0);
                   alpha=min(alpha,1.0);
                   color_fondo = np.array([0, 0, 0]);
                   color_fondo = np.tile(color_fondo, (image.shape[0], image.shape[1], 1));
                   image = image.astype(float) * alpha + color_fondo.astype(float) * (1 - alpha);
                   image = np.clip(image, 0, 255).astype(np.uint8);
                   
                salida = FaceLandmarks.draw_landmarks_on_image(image, results, self.params);
                self.signal_image(PIL.Image.fromarray(salida));

             if self.signal_landmarks():
                rt=[];
                for idx in range(len(results.face_landmarks)):
                    landmarks   = results.face_landmarks[idx];
                    blendshapes = results.face_blendshapes[idx];
                    matrix      = results.facial_transformation_matrixes[idx];
                    face={&#34;kind&#34;:f&#34;face::{0}&#34;, &#34;trust&#34;:0.0, &#34;matrix&#34;:matrix, &#34;xyz&#34;:[]};
                    for lm in landmarks:
                        face[&#34;xyz&#34;].append((lm.x, lm.y, lm.z));
                    rt.append(face);
                    
                self.signal_landmarks(rt);

             if self.signal_features():
                rt=[];
                for idx in range(len(results.face_landmarks)):
                    blendshapes = results.face_blendshapes[idx];
                    face = [ {&#34;index&#34;:bs.index, &#34;score&#34;:bs.score, &#34;name&#34;:bs.category_name} for bs in blendshapes ];
                    rt.append(face);
                    
                self.signal_features(rt);
                
             if self.signal_plot():
                if len(results.face_landmarks) &gt; 0:
                   for idx in range(len(results.face_landmarks)):
                       blendshapes = results.face_blendshapes[idx];
                       face = [ {&#34;index&#34;:bs.index, &#34;score&#34;:bs.score, &#34;name&#34;:bs.category_name} for bs in blendshapes ];
                       image = FaceLandmarks.plot_features(face);
                       self.signal_plot(image);
                else:
                   if self.params.emptyPlot:
                      face=[{&#34;index&#34;:n, &#34;score&#34;:0.0, &#34;name&#34;:FaceLandmarks.names(n)} for n in range(52)];
                      image = FaceLandmarks.plot_features(face);
                      self.signal_plot(image);
                
     #-------------------------------------------------------------------------
      # SIGNALS
      #-------------------------------------------------------------------------
      @Block.signal(&#34;image&#34;, Image)
      def signal_image(self, data):
          return data;

      @Block.signal(&#34;plot&#34;, Image)
      def signal_plot(self, data):
          return data;

      #-------------------------------------------------------------------------
      @Block.signal(&#34;landmarks&#34;, list)
      def signal_landmarks(self, data):
          return data;

      #-------------------------------------------------------------------------
      @Block.signal(&#34;features&#34;, list)
      def signal_features(self, data):
          return data;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ml4teens.core.block.Block" href="../../core/block.html#ml4teens.core.block.Block">Block</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="ml4teens.blocks.img.faceLandmarks.FaceLandmarks.draw_landmarks_on_image"><code class="name flex">
<span>def <span class="ident">draw_landmarks_on_image</span></span>(<span>rgb_image, detection_result, params)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def draw_landmarks_on_image(cls, rgb_image, detection_result, params):
    face_landmarks_list = detection_result.face_landmarks
    annotated_image = np.copy(rgb_image)
  
    # Loop through the detected faces to visualize.
    for idx in range(len(face_landmarks_list)):
      face_landmarks = face_landmarks_list[idx]
  
      # Draw the face landmarks.
      face_landmarks_proto = landmark_pb2.NormalizedLandmarkList()
      face_landmarks_proto.landmark.extend([ landmark_pb2.NormalizedLandmark(x=landmark.x, y=landmark.y, z=landmark.z) for landmark in face_landmarks ])
  
      if bool(params.drawAll) is True or bool(params.tesselation) is True:
         solutions.drawing_utils.draw_landmarks(image=annotated_image, 
                                                landmark_list=face_landmarks_proto, 
                                                connections=mp.solutions.face_mesh.FACEMESH_TESSELATION, 
                                                landmark_drawing_spec=None, 
                                                connection_drawing_spec=mp.solutions.drawing_styles.get_default_face_mesh_tesselation_style())
      if bool(params.drawAll) is True or bool(params.contours) is True:
         solutions.drawing_utils.draw_landmarks(image=annotated_image, 
                                                landmark_list=face_landmarks_proto, 
                                                connections=mp.solutions.face_mesh.FACEMESH_CONTOURS,    
                                                landmark_drawing_spec=None, 
                                                connection_drawing_spec=mp.solutions.drawing_styles.get_default_face_mesh_contours_style())               
      if bool(params.drawAll) is True or bool(params.irises) is True:
         solutions.drawing_utils.draw_landmarks(image=annotated_image, 
                                                landmark_list=face_landmarks_proto, 
                                                connections=mp.solutions.face_mesh.FACEMESH_IRISES,      
                                                landmark_drawing_spec=None, 
                                                connection_drawing_spec=mp.solutions.drawing_styles.get_default_face_mesh_iris_connections_style())
  
    return annotated_image    </code></pre>
</details>
</dd>
<dt id="ml4teens.blocks.img.faceLandmarks.FaceLandmarks.names"><code class="name flex">
<span>def <span class="ident">names</span></span>(<span>idx=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def names(cls, idx=None):
    
    if idx is None: return 52;
    
    if idx== 0: return &#34;_neutral&#34;;
    if idx== 1: return &#34;browDownLeft&#34;;
    if idx== 2: return &#34;browDownRight&#34;;
    if idx== 3: return &#34;browInnerUp&#34;;
    if idx== 4: return &#34;browOuterUpLeft&#34;;
    if idx== 5: return &#34;browOuterUpRight&#34;;
    if idx== 6: return &#34;cheekPuff&#34;;
    if idx== 7: return &#34;cheekSquintLeft&#34;;
    if idx== 8: return &#34;cheekSquintRight&#34;;
    if idx== 9: return &#34;eyeBlinkLeft&#34;;
    if idx==10: return &#34;eyeBlinkRight&#34;;
    if idx==11: return &#34;eyeLookDownLeft&#34;;
    if idx==12: return &#34;eyeLookDownRight&#34;;
    if idx==13: return &#34;eyeLookInLeft&#34;;
    if idx==14: return &#34;eyeLookInRight&#34;;
    if idx==15: return &#34;eyeLookOutLeft&#34;;
    if idx==16: return &#34;eyeLookOutRight&#34;;
    if idx==17: return &#34;eyeLookUpLeft&#34;;
    if idx==18: return &#34;eyeLookUpRight&#34;;
    if idx==19: return &#34;eyeSquintLeft&#34;;
    if idx==20: return &#34;eyeSquintRight&#34;;
    if idx==21: return &#34;eyeWideLeft&#34;;
    if idx==22: return &#34;eyeWideRight&#34;;
    if idx==23: return &#34;jawForward&#34;;
    if idx==24: return &#34;jawLeft&#34;;
    if idx==25: return &#34;jawOpen&#34;;
    if idx==26: return &#34;jawRight&#34;;
    if idx==27: return &#34;mouthClose&#34;;
    if idx==28: return &#34;mouthDimpleLeft&#34;;
    if idx==29: return &#34;mouthDimpleRight&#34;;
    if idx==30: return &#34;mouthFrownLeft&#34;;
    if idx==31: return &#34;mouthFrownRight&#34;;
    if idx==32: return &#34;mouthFunnel&#34;;
    if idx==33: return &#34;mouthLeft&#34;;
    if idx==34: return &#34;mouthLowerDownLeft&#34;;
    if idx==35: return &#34;mouthLowerDownRight&#34;;
    if idx==36: return &#34;mouthPressLeft&#34;;
    if idx==37: return &#34;mouthPressRight&#34;;
    if idx==38: return &#34;mouthPucker&#34;;
    if idx==39: return &#34;mouthRight&#34;;
    if idx==40: return &#34;mouthRollLower&#34;;
    if idx==41: return &#34;mouthRollUpper&#34;;
    if idx==42: return &#34;mouthShrugLower&#34;;
    if idx==43: return &#34;mouthShrugUpper&#34;;
    if idx==44: return &#34;mouthSmileLeft&#34;;
    if idx==45: return &#34;mouthSmileRight&#34;;
    if idx==46: return &#34;mouthStretchLeft&#34;;
    if idx==47: return &#34;mouthStretchRight&#34;;
    if idx==48: return &#34;mouthUpperUpLeft&#34;;
    if idx==49: return &#34;mouthUpperUpRight&#34;;
    if idx==50: return &#34;noseSneerLeft&#34;;
    if idx==51: return &#34;noseSneerRight&#34;;
    raise KeyError(f&#34;El índice {idx} no se corresponde con ningún face::landmark.&#34;);</code></pre>
</details>
</dd>
<dt id="ml4teens.blocks.img.faceLandmarks.FaceLandmarks.plot_features"><code class="name flex">
<span>def <span class="ident">plot_features</span></span>(<span>features)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def plot_features(cls, features):
  names  = [item[&#34;name&#34; ] for item in features];
  scores = [item[&#34;score&#34;] for item in features];
  
  ranks = range(len(names));

  with BytesIO() as buff:
       fig, ax = plt.subplots(figsize=(10, 10));
       bar = ax.barh(ranks, scores, label=[str(x) for x in ranks]);
       ax.set_yticks(ranks, names);
       ax.invert_yaxis();

       for score, patch in zip(scores, bar.patches):
           plt.text(patch.get_x() + patch.get_width(), patch.get_y(), f&#34;{score:.2f}&#34;, va=&#34;top&#34;);

       ax.set_xlabel(&#39;Score&#39;);
       ax.set_title(&#34;Features&#34;);
       plt.tight_layout();

       plt.savefig(buff, format=&#39;png&#39;);
       buff.seek(0);
       image = PIL.Image.open(buff)
       image.load();

       buff.close();
       plt.close();

  return image;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ml4teens.blocks.img.faceLandmarks.FaceLandmarks.signal_features"><code class="name flex">
<span>def <span class="ident">signal_features</span></span>(<span>self, data='497b45433bd959194961d1aab02c0de8b859338236ad84a831902785348b364e')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(self, data=_unique_):
    using=self.checkSignalUsage(name);
    if data is _unique_:
       return using;
    else:
       if using:
          data=func(self,data);
          Context.instance.emit(source=self, sname=name, data=data, mods=self._signal_mods);
          if sync:
             Context.instance.wait(forever=0, sync=sync);</code></pre>
</details>
</dd>
<dt id="ml4teens.blocks.img.faceLandmarks.FaceLandmarks.signal_image"><code class="name flex">
<span>def <span class="ident">signal_image</span></span>(<span>self, data='255507d5e0519bf1d911e1e5bba0bf70b7b38b1664698d41f5298c1775402466')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(self, data=_unique_):
    using=self.checkSignalUsage(name);
    if data is _unique_:
       return using;
    else:
       if using:
          data=func(self,data);
          Context.instance.emit(source=self, sname=name, data=data, mods=self._signal_mods);
          if sync:
             Context.instance.wait(forever=0, sync=sync);</code></pre>
</details>
</dd>
<dt id="ml4teens.blocks.img.faceLandmarks.FaceLandmarks.signal_landmarks"><code class="name flex">
<span>def <span class="ident">signal_landmarks</span></span>(<span>self, data='72fcdd713b07f46f805765b6cabdbe299b9c4eeb8c24b2566d05b05f14bcf27f')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(self, data=_unique_):
    using=self.checkSignalUsage(name);
    if data is _unique_:
       return using;
    else:
       if using:
          data=func(self,data);
          Context.instance.emit(source=self, sname=name, data=data, mods=self._signal_mods);
          if sync:
             Context.instance.wait(forever=0, sync=sync);</code></pre>
</details>
</dd>
<dt id="ml4teens.blocks.img.faceLandmarks.FaceLandmarks.signal_plot"><code class="name flex">
<span>def <span class="ident">signal_plot</span></span>(<span>self, data='6bdbb7b4d1d8b526818bfca6da64c349588f03ecbf13156efb14293d68c7d7a8')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(self, data=_unique_):
    using=self.checkSignalUsage(name);
    if data is _unique_:
       return using;
    else:
       if using:
          data=func(self,data);
          Context.instance.emit(source=self, sname=name, data=data, mods=self._signal_mods);
          if sync:
             Context.instance.wait(forever=0, sync=sync);</code></pre>
</details>
</dd>
<dt id="ml4teens.blocks.img.faceLandmarks.FaceLandmarks.slot_image"><code class="name flex">
<span>def <span class="ident">slot_image</span></span>(<span>self, _slot, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(self, _slot, data):
    try:
      assert name == _slot;
      debug.print(f&#34;Ejecutando {self._fullClassName}::slot(&#39;{_slot}&#39;,{type(data).__name__})&#39;&#34;);
      assert func is not None;
      assert callable(func);
      
      done=func(self, _slot, data);
      
      if self.params.done is not None:
         if callable(self.params.done):
            done=self.params.done(data);
         else:
            done=self.params.done;
         self.signal_done(done);
      else:
         if done is not None:
            self.signal_done(done);
         
    except Exception as e:
      debug.print(f&#34;{cls}:: Excepción: &#39;{e}&#39;&#34;, exception=e);
      
    finally:
      pass;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ml4teens.core.block.Block" href="../../core/block.html#ml4teens.core.block.Block">Block</a></b></code>:
<ul class="hlist">
<li><code><a title="ml4teens.core.block.Block.checkSignalUsage" href="../../core/block.html#ml4teens.core.block.Block.checkSignalUsage">checkSignalUsage</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ml4teens.blocks.img" href="index.html">ml4teens.blocks.img</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ml4teens.blocks.img.faceLandmarks.FaceLandmarks" href="#ml4teens.blocks.img.faceLandmarks.FaceLandmarks">FaceLandmarks</a></code></h4>
<ul class="">
<li><code><a title="ml4teens.blocks.img.faceLandmarks.FaceLandmarks.draw_landmarks_on_image" href="#ml4teens.blocks.img.faceLandmarks.FaceLandmarks.draw_landmarks_on_image">draw_landmarks_on_image</a></code></li>
<li><code><a title="ml4teens.blocks.img.faceLandmarks.FaceLandmarks.names" href="#ml4teens.blocks.img.faceLandmarks.FaceLandmarks.names">names</a></code></li>
<li><code><a title="ml4teens.blocks.img.faceLandmarks.FaceLandmarks.plot_features" href="#ml4teens.blocks.img.faceLandmarks.FaceLandmarks.plot_features">plot_features</a></code></li>
<li><code><a title="ml4teens.blocks.img.faceLandmarks.FaceLandmarks.signal_features" href="#ml4teens.blocks.img.faceLandmarks.FaceLandmarks.signal_features">signal_features</a></code></li>
<li><code><a title="ml4teens.blocks.img.faceLandmarks.FaceLandmarks.signal_image" href="#ml4teens.blocks.img.faceLandmarks.FaceLandmarks.signal_image">signal_image</a></code></li>
<li><code><a title="ml4teens.blocks.img.faceLandmarks.FaceLandmarks.signal_landmarks" href="#ml4teens.blocks.img.faceLandmarks.FaceLandmarks.signal_landmarks">signal_landmarks</a></code></li>
<li><code><a title="ml4teens.blocks.img.faceLandmarks.FaceLandmarks.signal_plot" href="#ml4teens.blocks.img.faceLandmarks.FaceLandmarks.signal_plot">signal_plot</a></code></li>
<li><code><a title="ml4teens.blocks.img.faceLandmarks.FaceLandmarks.slot_image" href="#ml4teens.blocks.img.faceLandmarks.FaceLandmarks.slot_image">slot_image</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>